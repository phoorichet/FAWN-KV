// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>
#include "SiltNode.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>

#include <thrift/transport/TSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/protocol/TBinaryProtocol.h>

#include "SiltCluster.h"
#include "fawnds_factory.h"
#include "print.h"
#include "csapp.h"

using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::silt;
using namespace std;
using namespace silt;

silt::FawnDS *h;

char *master_ip;
int master_port;
char *myIP;

#define SILTNODE_PORT 8888

class SiltNodeHandler : virtual public SiltNodeIf {
 public:
  SiltNodeHandler() {
    // Your initialization goes here
  }

  int32_t connect_master(const std::string& ip, const int32_t port) {
    // Your implementation goes here
    printf("connect_master\n");


    return 0;
  }

  int32_t put(const std::string& key, const std::string& value) {
    // Your implementation goes here
    // cout << "$$$ Client got PUT " << bytes_to_hex(key) << " -> " << bytes_to_hex(value) << endl;

    FawnDS_Return ret = h->Put(ConstRefValue(key.c_str(), key.size()), ConstRefValue(value.c_str(), value.size()));
    if (ret != silt::OK) {
      cout << "error! h->PUT() return key=" << bytes_to_hex(key) 
          <<  " value=" <<  bytes_to_hex(value) 
          << " ret=" << ret 
          << endl;
      //exit(1);
    } 

    return 0;
  }

  void get(std::string& _return, const std::string& key) {
    // Your implementation goes here
    printf("get\n");
    Value ret_data;
    ret_data.resize(0);

    // FawnDS_Return ret = h->Get(ConstRefValue(key, strlen(key)), ret_data);
    // if (ret != silt::OK) {
    //     printf("error! h->Get() return key=%s, ret=%d\n", 
    //            key, ret);
    //   }
      
  }

};


// char *getmyip() {
//   FILE * fp = popen("/sbin/ifconfig", "r");
//   char result[20];
//   if (fp) {
//     char *p=NULL, *e; size_t n;
    
//     while ((getline(&p, &n, fp) > 0) && p) {
//        if (p = strstr(p, "inet addr:")) {
//             p+=10;
//             if (e = strchr(p, ' ')) {
//                  *e='\0';
//                  printf("%s\n", p);
//                   char *ptr = p;
//                   int c=0;
//                   while( *ptr != '\n'){
//                     c++;
//                     ptr++;
//                     // printf("c=%d\n", c);
//                   }
                  
//                   strncpy(result, p, c);
//                   printf("Self IP=%s\n", result);
//                   break;
//             }
//        }
//     }


//   }
//   pclose(fp);
//   return result;
// }

int join_cluster(){
  cout << "Connecting to " << master_ip << ":" << master_port << endl;

  boost::shared_ptr<TSocket> socket(new TSocket(master_ip, master_port));
  boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  
  SiltClusterClient *client;
  client = new SiltClusterClient(protocol);
  transport->open();
  int rc = 0;
  if ((rc=client->join(myIP, SILTNODE_PORT)) != 0){
    cout << "##### client connot connect to " << master_ip << ":" << master_port << endl;
  }else{
    cout << "##### client connected to " << master_ip << ":" << master_port << endl;
  }
  
  return rc;
}

int main(int argc, char **argv) {

  if (argc < 3){
    cerr << "Usage: cluster_ip cluster_port xmlconfig" << endl;
    exit(1);
  }
  shared_ptr<SiltNodeHandler> handler(new SiltNodeHandler());
  shared_ptr<TProcessor> processor(new SiltNodeProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(SILTNODE_PORT));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  master_ip = argv[1];
  master_port = atoi(argv[2]);
  myIP = argv[3];
  char *xmlconfig = argv[4];


  cout << "##### master" << master_ip << ":" 
      << master_port << " - myport" << SILTNODE_PORT
       << xmlconfig << endl;

  // Create silt database
  h = silt::FawnDS_Factory::New(xmlconfig); // test_num_records_
  if (h->Create() != silt::OK) {
        cout << "cannot create FAWNDS!" << endl;
        exit(0);
  }

  // Join the cluster
  if (join_cluster() != 0)
  {
    h->Close();
    exit(1);
  }

  TThreadedServer server(processor,
                         serverTransport,
                         transportFactory,
                         protocolFactory);

  // TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  cout << "##### Running on port " << SILTNODE_PORT << endl;
  server.serve();

  h->Close();
  return 0;
}

