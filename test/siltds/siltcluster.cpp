// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "SiltCluster.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>

#include <thrift/transport/TSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/protocol/TBinaryProtocol.h>

#include "print.h"
#include "csapp.h"
#include "master.h"
#include "fawnds_factory.h"
#include "fawnds_types.h"
#include "fawnds.h"
#include "hashutil.h"

#define MAX_KEY_LENGTH 20

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

using namespace  ::silt;
using namespace std;

class SiltClusterHandler : virtual public SiltClusterIf {
 public:
  SiltClusterHandler() {
    // Your initialization goes here
    // boost::shared_ptr<TSocket> socket(new TSocket("128.2.131.18", 8888));
    // boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    // boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    
    // client = new SiltClusterClient(protocol);
    // transport->open();
    

    cache_init();
  }


  int32_t join(const std::string& ip, const int32_t port) {
    // Your implementation goes here
    
    cout << "JOIN " << ip << " " << port << endl;
    cache_insert(ip, port, MAX_KEY_LENGTH);

    return 0;
  }

  int32_t leave(const std::string& ip, const int32_t port) {
    // Your implementation goes here
    
    cout << "LEAVE " << ip << " " << port << endl;
    cache_delete(ip, port, MAX_KEY_LENGTH);

    return 0;
  }

  int32_t put(const std::string& key, const std::string& value) {
    // Your implementation goes here
    // printf("put\n");
    // cout << "PUT " << bytes_to_hex(key) << " -> " << bytes_to_hex(value) << endl;
    int32_t rc = -1;

    CacheObject *cacheobj = cache_get(key);
    if (cacheobj != NULL){

      // cout << "FOUND at IP: " << cacheobj->siltip << endl;
      if (cacheobj->client == NULL){
        boost::shared_ptr<TSocket> socket(new TSocket(cacheobj->siltip, cacheobj->port));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        
        cacheobj->client = new SiltClusterClient(protocol);
        sem_init(&(cacheobj->client_w), 0, 1);

        transport->open();

      }
      sem_wait(&(cacheobj->client_w)); /* Lock mutex */
      rc = cacheobj->client->put(key, value);
      sem_post(&(cacheobj->client_w)); /* Unlock mutex */
    }

    // return client->put(key, value);
    return rc;
  }

  void get(std::string& _return, const std::string& key) {
    // Your implementation goes here
    // cout << "PUT " << bytes_to_hex(key) << endl;
    int32_t rc = -1;
    CacheObject *cacheobj = cache_get(key);
    if (cacheobj != NULL){

      // cout << "FOUND at IP: " << cacheobj->siltip << endl;
      if (cacheobj->client == NULL){
        boost::shared_ptr<TSocket> socket(new TSocket(cacheobj->siltip, cacheobj->port));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        
        cacheobj->client = new SiltClusterClient(protocol);
        sem_init(&(cacheobj->client_r), 0, 1);

        transport->open();

      }
      // sem_wait(&(cacheobj->client_r)); /* Lock mutex */
      cacheobj->client->get(_return, key);
      // sem_post(&(cacheobj->client_r)); /* Unlock mutex */
    }

    return;

  }
private:
  SiltClusterClient *client;


  struct cacheobject_t {
    struct cacheobject_t *prev, *next;
    char siltip[20];
    int port;
    char *hash;
    SiltClusterClient *client;
    sem_t client_w, client_r;
    // boost::shared_ptr<TTransport> *transport;
  };
  typedef struct cacheobject_t CacheObject;

  typedef struct {
      CacheObject *head, *tail;
      size_t size;
      sem_t mutex, w;
      int readcnt;
  } cache_t;

  cache_t cache;

  void cache_init() {
    sem_init(&cache.mutex, 0, 1);
    sem_init(&cache.w, 0, 1);
    cache.head = cache.tail = NULL;
    cache.size = 0;
    cache.readcnt = 0;
  }

  CacheObject *cache_get(string skey) {
    char *key = strdup(skey.c_str());
    CacheObject *ret_obj = NULL;
    

    // printf("[Thread %u] :cache_get: sem_wait(&cache.mutex)\n", (unsigned int)pthread_self());
    // sem_wait(&cache.mutex);
    // cache.readcnt++;
    // if (cache.readcnt == 1) {
    //     printf("[Thread %u] :cache_get: sem_wait(&cache.w)\n", (unsigned int)pthread_self());
    //   sem_wait(&cache.w);
    // }
    // printf("[Thread %u] :cache_get: readcnt = %d\n", (unsigned int)pthread_self(), cache.readcnt);
    // printf("[Thread %u] :cache_get: sem_post(&cache.mutex)\n", (unsigned int)pthread_self());
    // sem_post(&cache.mutex);

    CacheObject *ptr = cache.head;
    // cout << "~~~~~~~ Looking for key " << bytes_to_hex(key) << endl;
    while (ptr != NULL) {
      // cout << "\tLooking cache key = " << bytes_to_hex(ptr->hash) << endl;

      if (ptr->next != NULL){
        /* Compare the two nodes, if key is in range, insert it between */
        if( (strcasecmp(key, ptr->hash) >= 0) &&
           (strcasecmp(key, ptr->next->hash) < 0) ){
            ret_obj = ptr;
            break;
        }  
      }else{
        if (ptr->prev == NULL){ // First node
            ret_obj = ptr;
            break;
        }else{ // last node
            if (strcasecmp(key, ptr->hash) >= 0){
              ret_obj = ptr;
              break;
            }else{
              ret_obj = ptr->prev;
              break;
            }
        }
      }
      
      ptr = ptr->next;
    }
    
    // if (ret_obj != NULL)
    //   cout << "\tfound key " << bytes_to_hex(key) << " at nodeid " << bytes_to_hex(ptr->hash) << endl;
    // else
    //   cout << "##### db missed" << endl;

    // printf("[Thread %u] :cache_get: sem_wait(&cache.mutex)\n", (unsigned int)pthread_self());
    // sem_wait(&cache.mutex); /* Lock mutex */
    // cache.readcnt--;
    // if (cache.readcnt == 0) {
    //     printf("[Thread %u] :cache_get: sem_post(&cache.w)\n", (unsigned int)pthread_self());
    //   sem_post(&cache.w);
    // }
    // printf("[Thread %u] :cache_get: readcnt = %d\n", (unsigned int)pthread_self(), cache.readcnt);
    // sem_post(&cache.mutex); /* Unlock mutex */
    // printf("[Thread %u] :cache_get: sem_post(&cache.mutex)\n", (unsigned int)pthread_self());

    assert(ret_obj != NULL);

    return ret_obj;
  }

  CacheObject *cache_delete(string ip, int port, size_t key_len) {
    // char *key = strdup(skey.c_str());    
    CacheObject *ret_obj = NULL;
    cout << "\tDeleting IP" << ip << ":" << port << endl;

    // printf("[Thread %u] :cache_get: sem_wait(&cache.mutex)\n", (unsigned int)pthread_self());
    // sem_wait(&cache.mutex);
    // cache.readcnt++;
    // if (cache.readcnt == 1) {
    //     printf("[Thread %u] :cache_get: sem_wait(&cache.w)\n", (unsigned int)pthread_self());
    //   sem_wait(&cache.w);
    // }
    // printf("[Thread %u] :cache_get: readcnt = %d\n", (unsigned int)pthread_self(), cache.readcnt);
    // printf("[Thread %u] :cache_get: sem_post(&cache.mutex)\n", (unsigned int)pthread_self());
    // sem_post(&cache.mutex);

    CacheObject *ptr = cache.head;
    cout << "~~~~~~~ Looking for key " << ip << ":" << port << endl;
    while (ptr != NULL) {
      cout << "\tComparing cache key = " << ptr->siltip << ":" << ptr->port << endl;
      if( (strcasecmp(ip.c_str(), ptr->siltip) == 0 ) && ( ptr->port == port)){
        // Remove the node
        

        if (ptr->prev != NULL){
            ptr->prev->next = ptr->next;
        }

        if (ptr->next != NULL){
          ptr->next->prev = ptr->prev;
        }

        if (ptr->prev == NULL && ptr->next == NULL){ // only one node
          cache.head = NULL;
          cache.tail = NULL;
          // printf("+++++++++++++\n");
        }

        if (cache.head == ptr){
          cache.head = ptr->next;
        }

        cout << "\tDeleted cache key = " << bytes_to_hex(ptr->hash) << endl;
        free(ptr);
        ret_obj = ptr;
        print_cache();
        break;
      }
      
      ptr = ptr->next;
    }
    
    // if (ret_obj != NULL)
    //   cout << "\tfound key " << bytes_to_hex(key) << " at nodeid " << bytes_to_hex(ptr->hash) << endl;
    // else
    //   cout << "##### db missed" << endl;

    // printf("[Thread %u] :cache_get: sem_wait(&cache.mutex)\n", (unsigned int)pthread_self());
    // sem_wait(&cache.mutex); /* Lock mutex */
    // cache.readcnt--;
    // if (cache.readcnt == 0) {
    //     printf("[Thread %u] :cache_get: sem_post(&cache.w)\n", (unsigned int)pthread_self());
    //   sem_post(&cache.w);
    // }
    // printf("[Thread %u] :cache_get: readcnt = %d\n", (unsigned int)pthread_self(), cache.readcnt);
    // sem_post(&cache.mutex); /* Unlock mutex */
    // printf("[Thread %u] :cache_get: sem_post(&cache.mutex)\n", (unsigned int)pthread_self());


    return ret_obj;
  }

  /* Assume that there's no object with the same nodeid in the cache */
  int cache_insert(string ip, int port, size_t key_len) {

    /* Create a new cache object. Copy data to the cache object's */
    CacheObject *newobject = (CacheObject *)calloc(1, sizeof(CacheObject));
    newobject->hash = (char *)calloc(1, MAX_KEY_LENGTH);  
    newobject->port = port;
    
    string ipport = ip;
    ostringstream convert;
    convert << port;
    ipport.append(convert.str());
    cout << "ip+port: " << ipport << endl;
    char *cip = strdup(ipport.c_str());
    memcpy(newobject->siltip, cip, ip.size());
    // cout << "ip:" << ip <<  " vs " << newobject->siltip << endl;

    // (newobject->siltip)(ip);
    string key = HashUtil::MD5Hash(newobject->siltip, MAX_KEY_LENGTH);
    char *ckey = strdup(key.c_str());
    // memcpy(newobject->nodeid, nodeid, strlen(nodeid));
    memcpy(newobject->hash, ckey, MAX_KEY_LENGTH);
    
    printf("[Thread %u] :insert: sem_wait(&cache.w)\n", (unsigned int)pthread_self());
    sem_wait(&cache.w); /* Lock writer */

    /* There is no node in the list */
    if (cache.head == NULL && cache.tail == NULL) {
      cache.head = newobject;
      cache.tail = newobject;
      newobject->prev = NULL;
      newobject->next = NULL;
      // printf( %s\n", nodeid);
      cout << "~~~~~~~ init a new node: " << ip << " : " << bytes_to_hex(key) << endl;
    } else {
      /* Seach for the node that has nodeid < the given nodeid and 
                    the next nodeid > the given nodeid */
      CacheObject *ptr = cache.head;
        cout<< "~~~~~~~ Looking for hash = " << bytes_to_hex(newobject->hash) << endl;
        while (ptr != NULL) {
          cout<< "\tLooking for hash = " << bytes_to_hex(ptr->hash) << endl;
          /* Look for a cache object with the same nodeid.
            When found, move this object to the tail.
            Then return this object. */
          if (ptr->next != NULL){ // More than 2 nodes exist 
            
              CacheObject *next_node = ptr->next;
              /* Compare the two nodes, if nodeid is in range, insert it between */
              if( (strcasecmp(ckey, ptr->hash) > 0) &&
                 (strcasecmp(ckey, next_node->hash) < 0) )
              {
                  ptr->next = newobject;
                  newobject->prev = ptr;
                  newobject->next = next_node;
                  next_node->prev = newobject;
                  // printf("\tinsert %s between\n", ip);
                  break;
              }

          }else{ // One node exists
            // if (newobject->hash.compare(ptr->hash) > 0){
            if (strcasecmp(ckey, ptr->hash) > 0){

              // insert after the ptr node
              newobject->next = ptr->next;
              ptr->next = newobject;
              newobject->prev = ptr;

              if (cache.tail == ptr){
                cache.tail = newobject;
              }

              cout << "\tInsert after " << bytes_to_hex(ptr->hash) << endl;
              break;
            // }else if (newobject->hash.compare(ptr->hash) < 0 ){
            }else if (strcasecmp(ckey, ptr->hash) < 0){
              // insert before the ptr node
              newobject->prev = ptr->prev;
              newobject->next = ptr;

              if (ptr->prev != NULL){
                ptr->prev->next = newobject; 
              }else{
                newobject->prev = NULL;
              }

              ptr->prev = newobject;

              // change the cache head
              if (cache.head == ptr){
                cache.head = newobject;  
              }

              cout << "\tInsert before " << bytes_to_hex(ptr->hash) << endl;
              break;
            }else{
              // Replace the old node
              newobject->next = ptr->next;
              newobject->prev = ptr->prev;
              // change the cache head
              if (cache.head == ptr){
                cache.head = newobject;  
              }
              if (cache.tail == ptr){
                cache.tail = newobject;
              }
              cout << "\tReplace existing node " << bytes_to_hex(ptr->hash) << endl;
              break;
            }
          }

          ptr = ptr->next;
        }

    }
    /* Update cache size */

    printf("[Thread %u] :insert: sem_post(&cache.w)\n", (unsigned int)pthread_self());
    sem_post(&cache.w); /* Unlock writer */

    print_cache();

    return 0;
  }


  void print_cache() {
    printf("** Node ID List **\n");
    CacheObject *ptr = cache.head;
    while (ptr != NULL) {
      cout << "\t" << bytes_to_hex(ptr->hash) << endl;
      ptr = ptr->next;
    }
    printf("** end **\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  int workers = 15;
  shared_ptr<SiltClusterHandler> handler(new SiltClusterHandler());
  shared_ptr<TProcessor> processor(new SiltClusterProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  // shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);
  // shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  // threadManager->threadFactory(threadFactory);
  // threadManager->start();
  // TThreadPoolServer server(processor,
  //                          serverTransport,
  //                          transportFactory,
  //                          protocolFactory,
  //                          threadManager);

  TThreadedServer server(processor,
                         serverTransport,
                         transportFactory,
                         protocolFactory);

  // TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  cout << "##### Running on port " << port << endl;
  server.serve();
  return 0;
}

